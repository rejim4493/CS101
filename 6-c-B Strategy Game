/*模擬回合制得分：J 位玩家、R 回合；根據每回合輸入的名次（或勝者）累加分數，最後輸出得分最高者（依題意處理同分規則／索引基底）。*/
/*
A strategy game with J players is played around a table. Players are identified by numbers from 1 to
J and will play a total of R rounds.
At each round each player will play once, in the order of their identifiers; that is, player 1 will play
first, player 2 will play second, and so on. Once player J plays, the round is complete, and a next round
starts.
A player earns a certain amount of Victory Points every time she or he plays. After all rounds are
finished the total points of each player is computed as the sum of Victory Points the player earned on
each round. The winner is the player with the maximum number of points; in case of a tie the winner
is the player who earned the maximum number of points and played last.
Given the number of players, the number of rounds and a list describing the Victory Points in the
order they were obtained, you must determine which player is the winner.
Input
The input contains several test cases. In each test case, the first line contains two integers J and R,
respectively the number of players and the number turns (1 ≤ J, R ≤ 500). The second line contains
J ∗ R integers, representing the Victory Points earned by each player in each turn, in the order they
happened. The Victory Points obtained in each turn will be always integer numbers between 0 and
100, inclusive.
Output
For each test case in the input, your program must produce one single line, containing the integer
representing the winner.
Sample Input
3 3
1 1 1 1 2 2 2 3 3
2 3
0 0 1 0 2 0
Sample Output
3
1
*/
#include <stdio.h>

int main()
{
    
        //int R[500] = {};
        int J=0;
        int R=0;
    while(scanf("%d%d", &J, &R) == 2)
    {
        
        int JR[501] = {};
        for(int i = 0;i < R; i+=1)//第幾局
        {
            for(int j = 0;j < J; j+=1)//第幾個玩家
            {
                int point = 0;
                scanf("%d", &point);
                JR[j] += point;
            }
        }
        int win = -1, winner = 0;
        for(int i = 0 ; i<J;i+=1)
        {
            if(JR[i] >= win)
            {
                win = JR[i];
                winner = i+1;
            }
        }
        printf("%d\n", winner);
    }
    return 0;
}

/*
好的，我幫你整理一下你在幾次程式修改過程中犯的錯誤，讓你更清楚整個學習脈絡：

---

## 你犯過的錯誤清單

### 1. 陣列宣告錯誤
- 一開始宣告 `int JR[500] = {};`，但卻用 `JR[i][j]` 當成二維陣列來存取。
- **錯誤原因**：一維陣列不能用兩個索引。
- **修正方式**：改成 `int JR[500][500];` 或者只用一維陣列存總分。

---

### 2. 只看一局分數
- 你用 `int x = R-(R-1);`，這永遠等於 1，只會看第 1 局的分數。
- **錯誤原因**：題目要求的是「所有回合的總分」，而不是某一局。
- **修正方式**：用一個陣列 `total[j]` 或直接在 `JR[j]` 累加每局分數。

---

### 3. 沒有累加分數
- 在某些版本中，你用 `scanf("%d", &JR[j]);`，這會覆蓋掉之前的分數。
- **錯誤原因**：只存最後一次輸入，沒有累加。
- **修正方式**：改成：
  ```c
  int point;
  scanf("%d", &point);
  JR[j] += point;
  ```

---

### 4. 贏家判斷邏輯錯誤
- 你一開始只更新 `winner`，沒有更新 `win`。
- **錯誤原因**：這樣比較條件永遠錯誤，因為 `win` 沒有跟著更新。
- **修正方式**：
  ```c
  if (JR[i] >= win) {
      win = JR[i];
      winner = i + 1;
  }
  ```

---

### 5. 陣列索引範圍錯誤
- 曾經用 `for(int i = 1; i < J+1; i++)`，但陣列索引應該是 `0` 到 `J-1`。
- **修正方式**：用 `for(int i = 0; i < J; i++)`，最後輸出時再 `i+1`。

---

### 6. 無窮迴圈
- 曾經用 `while(1)`，導致程式不會結束。
- **錯誤原因**：題目要求「多組測資直到 EOF」，不是無窮迴圈。
- **修正方式**：改成 `while(scanf("%d%d", &J, &R) == 2)`。

---

### 7. 陣列沒有重置
- 在某些版本中，`JR[501]` 宣告在迴圈外，導致多組測資會累加到一起。
- **修正方式**：把 `int JR[501] = {0};` 放到 `while` 裡面，每組測資重新歸零。

---

### 8. 輸出格式
- 一開始用 `printf("%d", winner);`，多組測資結果會黏在一起。
- **修正方式**：改成 `printf("%d\n", winner);`。

---

## 總結
你一路上犯的錯誤主要分成幾類：
1. **資料結構錯誤**（一維 vs 二維陣列）。
2. **邏輯錯誤**（只看一局、沒有累加、沒有更新最大值）。
3. **索引錯誤**（從 1 開始而不是 0）。
4. **流程控制錯誤**（無窮迴圈、沒有重置陣列）。
5. **輸出格式錯誤**（缺少換行）。

---

要不要我幫你整理成一個「錯誤 → 正確寫法」的對照表，讓你更快複習？
*/
