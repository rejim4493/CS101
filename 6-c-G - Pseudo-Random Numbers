/*
UVA350
用一個布林陣列去紀錄這串種子碼的數字，有出現就改true，測資3特別有問題，因為第一個L是種子碼以外的數，所以要
多計算一次才能進入循環，在計算迴圈外多算一次即可，其他測資不影響，因為只要在循環內，該算的還是會被算到。
7 5 12 12會多算一次
7 5 12 11會正常
應該是跟mod值有關

  Computers normally cannot generate really random numbers, but frequently are used to generate
sequences of pseudo-random numbers. These are generated by some algorithm, but appear for all
practical purposes to be really random. Random numbers are used in many applications, including
simulation.
A common pseudo-random number generation technique is called the linear congruential method.
If the last pseudo-random number generated was L, then the next number is generated by evaluating
(Z × L + I) mod M, where Z is a constant multiplier, I is a constant increment, and M is a constant
modulus. For example, suppose Z is 7, I is 5, and M is 12. If the first random number (usually called
the seed) is 4, then we can determine the next few pseudo-random numbers are follows:
Last Random Number, L || (Z × L + I)|| Next Random Number, (Z × L + I) mod M
4 || 33 || 9
9 68 8
8 61 1
1 12 0
0 5 5
5 40 4
As you can see, the sequence of pseudo-random numbers generated by this technique repeats after
six numbers. It should be clear that the longest sequence that can be generated using this technique is
limited by the modulus, M.
In this problem you will be given sets of values for Z, I, M, and the seed, L. Each of these will
have no more than four digits. For each such set of values you are to determine the length of the cycle
of pseudo-random numbers that will be generated. But be careful: the cycle might not begin with the
seed!
Input
Each input line will contain four integer values, in order, for Z, I, M, and L. The last line will contain
four zeroes, and marks the end of the input data. L will be less than M.
Output
For each input line, display the case number (they are sequentially numbered, starting with 1) and the
length of the sequence of pseudo-random numbers before the sequence is repeated.
Sample Input
7 5 12 4
5173 3849 3279 1511
9111 5309 6000 1234
1079 2136 9999 1237
0 0 0 0
Sample Output
Case 1: 6
Case 2: 546
Case 3: 500
Case 4: 220
*/
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int Z = 0;//乘數
    int I = 0;//加數
    int M = 0;//模數
    int L = 0;//上一個數字
    int casenum = 1;
    while(scanf("%d%d%d%d", &Z, &I, &M, &L) == 4&&Z != 0&&I != 0&& M != 0&&L !=0)
    {
        bool seen[10000] = {false};
        int count = 0;
        L = (Z * L + I) % M;
        
        while(!seen[L]){
            seen[L] = true;
            L = (Z * L + I) % M;//算下一個數字
            count++;
        }

        printf("Case %d: %d\n", casenum, count);
        casenum += 1;
    }
    return 0;
}

/*
while(!seen[L]){
            seen[L] = true;
            count++;
            L = (Z * L + I) % M;//算下一個數字
        }
Input
7 5 12 4
5173 3849 3279 1511
9111 5309 6000 1234
1079 2136 9999 1237
0 0 0 0
Output
Case 1: 6
Case 2: 546
Case 3: 501
Case 4: 220

case 3會錯，因為不是從種子值開始，那就會多算一次
*/
